
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Mon Portfolio</title>
  <link rel="stylesheet" href="style.css">

  <!-- Highlight.js pour coloration syntaxique -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
  <script>hljs.highlightAll();</script>

  <style>
    pre {
      background: #f0f0f0;
      padding: 1em;
      overflow-x: auto;
      border-radius: 8px;
    }
    details {
      margin-top: 1em;
    }
  </style>
</head>
<body>
  <header>
    <h1>Bienvenue sur mon portfolio</h1>
    <p>Je m'appelle nadal NGAKI MUPATI, je suis √©tudiant en deuxi√®me ann√©e de licence sciences pour l'ing√©nieur, voici mes diff√©tents projets personnels et acad√©miques concernant la programmation informatique.</p>
  </header>

  <section>
    <h2>Mes projets</h2>
    <ul>
      <li>
        <strong>Projet 1 : Jeu vid√©o - Eco-Guerrier</strong><br>
        <p>
          Une simulation ludique en Python avec interface Tkinter et gestion de carte maritime. Le joueur incarne un navire √©cologique (OMI)
          charg√© d'intercepter les pollueurs (OP) et de prot√©ger les zones marines.
        </p>
        <ul>
          <li>D√©placement en temps r√©el sur carte avec collisions</li>
          <li>Ajout de zones prot√©g√©es et traitement des nappes d‚Äôhydrocarbures</li>
          <li>Gestion d‚Äôun budget, chronom√®tre, enregistrement de score</li>
          <li>Cheat codes pour interagir avec l'environnement (nappes, plateformes...)</li>
        </ul>

        <p><strong>Code source :</strong></p>
        <details>
          <summary>Afficher/masquer le script complet</summary>
          <pre><code class="language-python">
"""
Projet : Eco guerrir
Auteur : NGAKI MUPATI NADAL
"""

#Modules import√©s
from tkinter import *
import random
import math
import numpy as np
import tkinter as tk
from tkinter import messagebox
import matplotlib.pyplot as plt

# ----------------------------------------------------------------
# Variables globales
# ----------------------------------------------------------------

#Liste des entites mobiles (ID)
entitesMobiles=[]
#Liste des entit√©s mobiles
typesEntiteMobile=[]
TYPE_ORGA_MARITIME=1
TYPE_ORGA_PETROL=5
TYPE_NAPPE_HYDRO=6

#A int√©grer
etats_chargement=[]
ETAT_CHARGEMENT_MIN=0
ETAT_CHARGEMENT_MAX=100
#DEGAT_ORGA_PETROL=10

#Coordonn√©es initiales de tous les navires
coord_iEntitesMobiles_Init=[]#Abscisse Navires
coord_jEntitesMobiles_Init=[]#Ordonn√©e Navires

#Coordonn√©es actuelles de tous les navires
coord_iEntitesMobiles=[]#Abscisse Navires >> nombre r√©√©l √† convertir en entier pour utiliser en coordonn√©es matricielle
coord_jEntitesMobiles=[]#Ordonn√©e Navires


#Vitesses actuelles de tous les navires
vitX=[]
vitY=[]
#Distance incr√©ment√©e √† chaque d√©placement
VIT_MAX_OrgaMaritime = 0.04
VIT_MAX_OrgaPetrole = 0.03

### Legende des Matrices de d√©cor ###
#Zones naviguables
ZN=10#Zone maritime neutre : non explit√©e/non prot√©g√©e
ZP=11#Zone maritime prot√©g√©e
BP=20#Base portuaire p√©troli√®re
PP=30#Plateforme p√©troli√®re
BM=40#Base portuaire OMI
CG=60     #coin gauche haut 
CD=70     #coin droite haut
CDh=80    #coin droite bas 
CGh=90    #coin gache bas
CH=100    #cote haut 
CB=110    #cote bas
cG=120    #cote gauche
cD=140    #cote droite 

#Zones non naviguable
ZT=50#Zone terrestre




#Matrice de la carte du Niveau 1
matValCarteN1 = [
    [CG, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CH, CD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, CG, CH, CD, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, cG, ZT, cD, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, CGh, CB, CDh, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, PP, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, BM, ZP, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, BP, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [cG, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, ZN, cD],
    [CGh, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CB, CDh]
]



matValCarteN1_initial=np.copy(matValCarteN1)#Copie pout conservation des valeurs initiales durant la simulation

#Dimension de chaque case en pixel
LARG_CASE=40#Largeur
HAUT_CASE=40#Hauteur

#Dimensions
LARG_CANVAS = len(matValCarteN1)*LARG_CASE
HAUT_CANVAS = len(matValCarteN1[0])*HAUT_CASE

#Etat des animations et d√©placements
etat_actif_depl_anim = False

#Demande d'arr√™t
dde_arret = False

#Gestion du budget
budgetOM=budgetOM_INIT=2000
budgetOP=budgetOP_INIT=2000
tarifSANCTION=500#Tarif d'une sanction en cas de d√©crouverte d'une nappe
tarifVENTE=100#Tarif d'une vente de p√©trole
tarifTRAITEMENT=100#Tarif de traitement de d√©chets
tarifDEGAT=500#Tarif de destruction d'une zone prot√©g√©e

#dur√©e de simulation
dureeSimulation=0#en s
tpsRafraichissement=0.1#en s
# dureePP_Initiale=10#en s
dureePP_Initiale=20#en s
# dureePP=10#en s
dureePP=20#en s
# dureeZP_Initiale=10#en
dureeZP_Initiale=20#en s
#dureeZP=10#en s
dureeZP=20#en s

#---------------------------------------------------------------------------------------------------------
# LES DIFFERENTS VARRIABLES QUE J'AI INITIALISEES TOUT AU DEBUT 
#---------------------------------------------------------------------------------------------------------

NAVIRE_PIRATE=4    # initialisation de mon navire pirate 
VIT_MAX_NAVIRE_PIRATE = 0.06    #vitesse du navire pirate

# temps pour le chronometre 
duree_partie = 0  # Temps √©coul√© en secondes
chrono_actif = False  # Indique si le chronom√®tre est en cours

FICHIER_BUDGET = "budget.txt"  # declaration du budget comme fichier txt

nom_utilisateur = input("entrez votre nom, celui-ci doit etre identique avec le nom que vous saisirez en debut de partie  : ")   # pour l'association du record avec le nom de l'utilisateur

#suivi du budget et le temps pour le graphe
temps = []
budgets_om = []
budgets_op = []



# -----------------------------------------------------------------------------------------------------------
# FONCTIONS
# -----------------------------------------------------------------------------------------------------------


#-----------------------------------------------------------------------------------------------------------    
# Cheat Code 
#-----------------------------------------------------------------------------------------------------------

def afficher_tutoriel():
    """ Fonction pour afficher le tutoriel
    """
    tutoriel_window = tk.Toplevel(root)
    tutoriel_window.title("Tutoriel")
    texte_tutoriel = (
        "Bienvenue dans ce jeu Eco-Guerrier !\n\n"
        "Objectif :\n"
        "- Contr√¥lez le navire OM pour perturber le trafic de l'OP et lutter contre la pollution maritime.\n\n"

        "Instructions du jeu :\n"

        "- Fl√®ches directionnelles : D√©placer le navire OM\n"
        
        "- les Cheat Codes :\n"

        "- Touche 'n' : Supprimer les nappes d'hydrocarbures\n"

        "- Touche 'v' : Ajouter une zone prot√©g√©e\n"

        "- Touche 'p' : D√©placer la plateforme p√©troli√®re\n"

        "- Touche 'Espace' : D√©marrer/Arr√™ter la simulation\n"

        "Bonne chance !"
    )

    tk.Label(tutoriel_window, text=texte_tutoriel, justify="left", font=("calibri", 12)).pack(padx=20, pady=20)
    
     
def suppression_des_nappes_hydocarbures ():
    """suppression de la nappe hydrocarbure avec la touche n"""
    global budgetOM, budgetOP
    for i in range(len(entitesMobiles)-1, -1, -1): #pour un parcours invers√© afin d'√©viter les problemes de suppresion 
        if typesEntiteMobile[i]==TYPE_NAPPE_HYDRO and etats_chargement[i]==ETAT_CHARGEMENT_MAX:
            #suppression de l'image 
            gestionCanvas.delete(entitesMobiles[i])
            #suppresion des donn√©es reletives aux nappes 
            coord_iEntitesMobiles_Init.pop(i)
            coord_jEntitesMobiles_Init.pop(i)
            coord_iEntitesMobiles.pop(i)
            coord_jEntitesMobiles.pop(i)
            vitX.pop(i)
            vitY.pop(i)
            entitesMobiles.pop(i)
            typesEntiteMobile.pop(i)
            etats_chargement.pop(i)
            budgetOM+=tarifTRAITEMENT  #augmentation du budget de OM
            budgetOP-=tarifSANCTION    #reduction du budget de OP
            lblBudgetOM.config(text="budget OM :"+ str(budgetOM))
            lblBudgetOP.config(text="budget OP :"+ str(budgetOP))
            print("la suppression de la nappe a √©t√© un succes !") #message pour le suivi
            break  # pour sortir apres avoir supprim√© une nappe hydrocarbure 

def ajout_de_nouvelles_zones_proteg√©es():
    """Ajoute une nouvelle zone prot√©g√©e sur une zone neutre (ZN)."""
    global matValCarteN1
    newCoordZP = getCoordAleatoire([ZN], True, 1)
    matValCarteN1[newCoordZP[1]][newCoordZP[0]] = ZP  # Mettre √† jour la matrice
    gestionCanvas.itemconfig(matImgCarteN1[newCoordZP[1]][newCoordZP[0]], image=imgZP)  # Mise √† jour de l'affichage
    print(" Nouvelle zone prot√©g√©e ajout√©e !")  # Message pour suivi

def deplacement_de_la_plateforme_petroliere():
    """D√©place la plateforme p√©troli√®re vers une nouvelle zone neutre."""
    global matValCarteN1
    oldCoordPP = getCelluleZoneUnique(PP)
    newCoordPP = getCoordAleatoire([ZN], True, 1)
    
    # Mise √† jour des matrices
    matValCarteN1[newCoordPP[1]][newCoordPP[0]] = PP
    matValCarteN1[oldCoordPP[1]][oldCoordPP[0]] = ZN
    
    # Mise √† jour de l'affichage
    gestionCanvas.itemconfig(matImgCarteN1[oldCoordPP[1]][oldCoordPP[0]], image=imgZN)
    gestionCanvas.itemconfig(matImgCarteN1[newCoordPP[1]][newCoordPP[0]], image=imgPP)
    print("Plateforme p√©troli√®re d√©plac√©e avec succ√®s !")  # Message pour suivi
    
#----------------------------------------------------------------------------------------------------------   
# 5.2 Menu principal
#----------------------------------------------------------------------------------------------------------

def lancerSimulation():
    """ Fonction pour afficher le tutoriel
    """
    depart()                 # pour declencher le depart en appuyant sur le bouton respectif
    fen_princ.deiconify()    # pour lancer la simulation en appuyant sur le bouton respectif

#------------------------------------------------------------------------------------------------
# Affichage de la dur√©e de la partie
#------------------------------------------------------------------------------------------------

def miseAJourDuree():
    """ creation d'une fonction pour la mise √† jour du chronometre""" 
    global duree_partie, chrono_actif

    if chrono_actif:  # V√©rifie si le chronom√®tre est actif
        duree_partie += 1  # Incr√©mente le temps de jeu
        lblDureePartie.config(text=f"Dur√©e : {duree_partie}s")  # Met √† jour l'affichage
        fen_princ.after(1000, miseAJourDuree)  # Rappelle la fonction apr√®s 1 seconde

#-------------------------------------------------------------------------------------------------        
# Sauvegarde des Budgets & Record 
#-------------------------------------------------------------------------------------------------

def charger_record():
    """Charge le record (budget max) depuis le fichier."""
    budget1 = []
    try:
        fichier = open(FICHIER_BUDGET, "r")
        lignes = fichier.readlines()
        fichier.close()
        
        for ligne in lignes:
            elements = ligne.strip().split()
            if len(elements) >= 2:  # V√©rifie qu'il y a bien un budget et un nom
                try:
                    budget, nom = float(elements[0]), " ".join(elements[1:])
                    if nom == nom_utilisateur:  # V√©rifier si c'est le bon utilisateur
                        budget1.append(budget)  # stocher juste les budget dans notre tableau
                except ValueError:
                    continue  # Ignore les lignes invalides

        if budget1:
            return max(budget1)  # Trouver le budget max
        return None  # Aucun budget trouv√© pour l'utilisateur
    except FileNotFoundError:
        return None  # Si le fichier n'existe pas, retourner None

def sauvegarder_budget(budget):
    """Ajoute un budget au fichier et met √† jour l'affichage."""
    try:
        fichier = open(FICHIER_BUDGET, "a")    # ouvrir en mode ajout
        fichier.write(f"{budget} {nom_utilisateur}\n")    # ecrire le budget et le nom de l'utilisateur 
        fichier.close()       # fermer le fichier
    except IOError:
        print("Erreur lors de l'√©criture dans le fichier.")

def charger_tous_les_budgets():
    """Charge tous les budgets enregistr√©s et les trie du plus grand au plus petit."""
    budgets = []
    try:
        fichier = open(FICHIER_BUDGET, "r")
        lignes = fichier.readlines()
        fichier.close()

        for ligne in lignes:
            elements = ligne.strip().split()
            if len(elements) >= 2:
                try:
                    budget = float(elements[0])
                    budgets.append(budget)
                except ValueError:
                    continue  # Ignore les erreurs de conversion

        budgets.sort(reverse=True)  # Trier du plus grand au plus petit
        return budgets
    except FileNotFoundError:
        return []

def afficher_budget_et_record():
    """Affiche le budget et le record sur l'interface."""
    record = charger_record()
    lblBudgetRecord.config(text=f"Record : {record if record is not None else 'Aucun'} {nom_utilisateur}")

#--------------------------------------------------------------------------------
# Affichage du Classement 
#--------------------------------------------------------------------------------

def afficher_classement_final(budget_final):
    """Affiche un message de classement bas√© sur le budget final."""
    budgets = charger_tous_les_budgets()  # Charger tous les budgets class√©s

    if not budgets:  # Si aucun budget n'est enregistr√©
        message = "C'est votre premier budget enregistr√© !"
    elif budget_final == budgets[0]:  # Si c'est le record
        message = "üéâ Nouveau Record ! F√©licitations ! üéâ"
    else:
        try:
            position = budgets.index(budget_final) + 1  # Trouver la position
            message = f"üèÖ {position}√®me Meilleur Budget !"
        except ValueError:
            message = "Budget non trouv√© dans le classement."

    lblclassement.config(text=message)  # Mettre √† jour l'affichage 
    
#----------------------------------------------------------------------------------------
# saisi des noms et affichage du graphique de l'√©volution du budget en fonction du temps
#----------------------------------------------------------------------------------------

def utilisateur():
    """ fonction permettant de saisir le nom √† chaque debut de partie"""
    global nom_utlisateur
    nom_utilisateur = entree_nom.get()  # R√©cup√©rer le nom entr√© par l'utilisateur
    if nom_utilisateur.strip():  # V√©rifie si le champ n'est pas vide
        lblNom.config(text=f"Joueur : {nom_utilisateur}")  # Mettre √† jour l'affichage
        root.deiconify()      # delencher l'ouverture la fenetre du menu afin de pouvoir lance la simalation ou consulter les tutoriels
        nom_window.destroy()  # Fermer la fen√™tre
        
def enregistrer_budget_temps():
    """fonction qui permet d'enregister le budget en fonction du temps"""
    global budgetOM, budgetOP, duree_partie
    budgets_om.append(budgetOM) # stockage des differents budget de OM dans la liste budget_om
    budgets_op.append(budgetOP) # stockage des differents budget de OP dans la liste budget_op 
    temps.append(duree_partie)  # stockage du temps dans la liste duree_partie 

def afficher_graphe_final():
    """Fonction pour afficher le graphe √† la fin de la partie"""
    plt.figure(figsize=(8, 6))
    plt.plot(temps, budgets_om, label="Budget OM", color='green')
    plt.plot(temps, budgets_op, label="Budget OP", color='red')
    plt.xlabel("Temps (s)")
    plt.ylabel("Budget")
    plt.title("√âvolution du Budget pendant la Partie")
    plt.legend()
    plt.grid(True)
    plt.show()
    
#________________________________________________________________________________________      

def getCoordAleatoire(pTypesZones,pVoisinsEgalement=False,pBordure=0):
    """
Obj: Tirage al√©atoire d'un emplacement d'un type parmi ceux la liste pass√© en argument
Les zones en bordure ne sont pas prises en compte
Arg : liste des types zones qui nous interessent
Retour : liste de 2 √©lements : Coordonn√©es (en matriciel et non en pixel)
    """

    dispo=False
    while (not dispo):
        i=random.randint(pBordure,len(matValCarteN1)-1-pBordure)
        j=random.randint(pBordure,len(matValCarteN1[0])-1-pBordure)
  
        if (pVoisinsEgalement):
            if(len(voisinsDisponibles(matValCarteN1,pTypesZones,j,i))==8):
                dispo=(matValCarteN1[j][i] in pTypesZones)
        else:
            dispo=(matValCarteN1[j][i] in pTypesZones)

    return [i,j]


"""
Obj : Recherche les coordonn√©es d'une zone unique et forcement pr√©sente
Arg : type de zone unique recherch√©e
Retour : Coordonn√©es trouv√©es
"""
def getCelluleZoneUnique(pTYPE_ZONE):
    dispo=False
    i=0
    j=0
    while (not dispo):
        if (matValCarteN1[j][i]==pTYPE_ZONE):
            dispo=True
        else:
            j+=1
            if j>=(len(matValCarteN1)):
                j=0
                i+=1            
                if i>=(len(matValCarteN1[0])):
                    dispo=True#Rien n'a √©t√© trouv√©             

    return [i,j]

"""
Obj: Convertion des coordonn√©es r√©√©lles en coordonn√©es enti√®res pour consulter la matrice
Permet ainsi de conna√Ætre le type d'item qui occupe la case occup√© par le navire
Retour : liste de 2 √©lements : Coordonn√©es (en matriciel et non en pixel)

"""
def getCelluleEntiteMobile(pNoEntiteMobile):
    return [round(coord_iEntitesMobiles[pNoEntiteMobile]),round(coord_jEntitesMobiles[pNoEntiteMobile])]

"""
Obj: Convertir les indices de tableau en coordonn√©es pixel 
Param√®tres : indices du tableau niveau
Retour : liste des 2 coordonn√©es en pixel 
"""
def getConvertCoordNiveauEnCoordPixels(i,j):
    x=LARG_CASE*i
    y=HAUT_CASE*j
    return [x,y]

"""
Obj: Convertir les coordonn√©es pixel en indices de tableau niveau
Param√®tres : coordonn√©es pixel
Retour : liste des 2 indices du tableau matValCarteN1
"""
def getConvertCoordPixelsEnCoordNiveau(x,y):
    i=int(x/(LARG_CASE-(x%LARG_CASE)))
    j=int(y/(HAUT_CASE-(y%HAUT_CASE)))
    return [i,j]

"""
Obj: Convertir les coordonn√©es pixel en indices de tableau niveau
Param√®tres : image et nouvelles coordonn√©es en pixel
"""
def deplacerImage(im,newX,newY):
    global gestionCanvas
    gestionCanvas.coords(im,newX,newY,
                         newX+LARG_CASE,newY+HAUT_CASE)


"""
Obj: Gestion des √©v√®nements du clavier

"""
def evenements(event):
    if event.keysym=="Up":
        pilotage(0,0,-VIT_MAX_OrgaMaritime)# demarrage(0,-VIT_MAX_OrgaMaritime)#,btnHaut)
    elif event.keysym=="Down":
        pilotage(0,0,VIT_MAX_OrgaMaritime)#,btnBas)
    elif event.keysym=="Left":
        pilotage(0,-VIT_MAX_OrgaMaritime,0)#,btnGauche)
    elif event.keysym=="Right":
        pilotage(0,VIT_MAX_OrgaMaritime,0)#,btnDroite)
    elif event.keysym == "n":
        suppression_des_nappes_hydocarbures()
    elif event.keysym == "v":
        ajout_de_nouvelles_zones_proteg√©es()
    elif event.keysym == "p":
        deplacement_de_la_plateforme_petroliere()
        
    
    if event.keysym=="Escape":
        arret()
    elif event.keysym=="space":
        depart()

    

"""
Obj: Instanciation d'une nouvelle entit√© mobile (ex : navire, nappe hydrocarbure,etc..)
Param : Type d'entit√© mobile
"""
def creationEntiteMobile(pTypeEntiteMobile):
    global vitX,vitY,coord_iEntitesMobiles_Init,coord_jEntitesMobiles_Init,entitesMobiles
    global typesEntiteMobile,etats_chargement,gestionCanvas, posInitEntiteMobile
    
    if (pTypeEntiteMobile==TYPE_ORGA_MARITIME):
        posInitEntiteMobile=getCelluleZoneUnique(BM)#voisinsDisponibles(matValCarteN1,[ZT],getCelluleZoneUnique(BM)[0],getCelluleZoneUnique(BM)[1])[0]
    elif (pTypeEntiteMobile==TYPE_ORGA_PETROL):
        posInitEntiteMobile=getCelluleZoneUnique(BP)
    elif (pTypeEntiteMobile==TYPE_NAPPE_HYDRO):
        posInitEntiteMobile=getCelluleZoneUnique(PP)
    elif (pTypeEntiteMobile == NAVIRE_PIRATE):        # creation navire pirate 
        posInitEntiteMobile = getCoordAleatoire([ZN])  # Choisir une zone oc√©anique
    coord_i_EntiteMobile=posInitEntiteMobile[0]
    coord_j_EntiteMobile=posInitEntiteMobile[1]
    coord_iEntitesMobiles_Init.append(coord_i_EntiteMobile)
    coord_jEntitesMobiles_Init.append(coord_j_EntiteMobile)
    coord_iEntitesMobiles.append(coord_i_EntiteMobile)
    coord_jEntitesMobiles.append(coord_j_EntiteMobile)

    vitX.append(0)
    vitY.append(0)
    
    coordPixel=getConvertCoordNiveauEnCoordPixels(posInitEntiteMobile[0],posInitEntiteMobile[1])
    
    #matValCarteN1[coord_j_EntiteMobile][coord_i_EntiteMobile]=pTypeEntiteMobile
    if (pTypeEntiteMobile==TYPE_ORGA_MARITIME):
        entitesMobiles.append(gestionCanvas.create_image(coordPixel[0],coordPixel[1], image=imgBateauOMempty,anchor=NW))
        etats_chargement.append(ETAT_CHARGEMENT_MIN)
        gestionCanvas.tag_raise(entitesMobiles[-1])
    elif (pTypeEntiteMobile==TYPE_ORGA_PETROL):
        entitesMobiles.append(gestionCanvas.create_image(coordPixel[0],coordPixel[1], image=imgBateauOPempty,anchor=NW))
        etats_chargement.append(ETAT_CHARGEMENT_MIN)
        gestionCanvas.tag_raise(entitesMobiles[-1])
    elif (pTypeEntiteMobile==TYPE_NAPPE_HYDRO):
        entitesMobiles.append(gestionCanvas.create_image(coordPixel[0],coordPixel[1], image=imgZH,anchor=NW))
        etats_chargement.append(ETAT_CHARGEMENT_MAX)
    elif (pTypeEntiteMobile==NAVIRE_PIRATE):
        entitesMobiles.append(gestionCanvas.create_image(coordPixel[0],coordPixel[1], image=imgNAVIREPIRATE,anchor=NW))
        etats_chargement.append(ETAT_CHARGEMENT_MIN)
        gestionCanvas.tag_raise(entitesMobiles[-1])
    
    typesEntiteMobile.append(pTypeEntiteMobile)

"""
Obj: D√©marrage des d√©placements des entit√©s mobiles
Param :
    pVitesseX : Vitesse demand√©e par le joueur sur l'axe des abcisses
    pVitesseY : Vitesse demand√©e par le joueur sur l'axe des ordonn√©es
    pBtn : Bouton utilis√© dont l'apparence doit mise √† jour
"""
def pilotage(pNoEntiteMobile,pVitesseX,pVitesseY):
    global dde_arret,etat_actif_depl_anim,vitX,vitY
    
    if etat_actif_depl_anim == True:
        vitX[pNoEntiteMobile]=pVitesseX
        vitY[pNoEntiteMobile]=pVitesseY

"""
Obj: Appel r√©cursif des d√©placements de toutes les entit√©s mobiles
Basculer la valeur de dde_arret √† True pour stopper les d√©placements
"""
def gestion_deplacements():

    global etat_actif_depl_anim, dde_arret,dureeSimulation
    global dureePP,dureeZP,imgCarteLigne,gestionCanvas #,noEntiteMobile
    
# pour arreter toutes les entites mobiles
    if (etat_actif_depl_anim):
        for noEntiteMobile in range(len(entitesMobiles)):
            deplacement(noEntiteMobile)#,typesEntiteMobile[i])
            if typesEntiteMobile[noEntiteMobile] == NAVIRE_PIRATE:
                chgtDirectionOP(noEntiteMobile)

        enregistrer_budget_temps()
        
        #Gestion des √©volutions des zones PP et ZP
        dureePP-=tpsRafraichissement
        dureeZP-=tpsRafraichissement
        if (dureePP<0):#la PP a termin√© son exploitation, une nouvelle doit √™tre construite
            dureePP=dureePP_Initiale
            #d√©placer la PP
            oldCoordPP=getCelluleZoneUnique(PP)
            newCoordPP=getCoordAleatoire([ZN],True,1)
            matValCarteN1[newCoordPP[1]][newCoordPP[0]]=PP
            matValCarteN1[oldCoordPP[1]][oldCoordPP[0]]=ZN
            gestionCanvas.itemconfig(matImgCarteN1[oldCoordPP[1]][oldCoordPP[0]],image = imgZN)
            gestionCanvas.itemconfig(matImgCarteN1[newCoordPP[1]][newCoordPP[0]],image = imgPP)
        if (dureeZP<0):#la ZP est suffisemment d√©velopp√©e et une nouvelle peut √™tre am√©nag√©e
            dureeZP=dureeZP_Initiale
            #d√©placer la ZP
            newCoordZP=getCoordAleatoire([ZN],True,1)
            matValCarteN1[newCoordZP[1]][newCoordZP[0]]=ZP
            gestionCanvas.itemconfig(matImgCarteN1[newCoordZP[1]][newCoordZP[0]],image = imgZP)
    
    
    if dde_arret == False :#Tant que le simulateur ne doit pas √™tre arr√™t√©
        dureeSimulation+=tpsRafraichissement

        fen_princ.after(int(1000*tpsRafraichissement), gestion_deplacements)#Patienter 100ms afin d'appeler √† nouveau cette m√™me fonction (r√©cursivit√©)
    else:
        dde_arret = False #Arr√™t pris en compte et r√©initialis√©
        etat_actif_depl_anim = False #Animation d√©sactiv√©e
        
"""
Obj: Gestion de la logique de d√©placement des ennemis
Param :
    pNoEntiteMobile : Identifiant du navire concern√©
"""
def chgtDirectionOP(pNoEntiteMobile):
    global vitX, vitY, typesEntiteMobile
    
    if typesEntiteMobile[pNoEntiteMobile] == NAVIRE_PIRATE:
        direction = random.randint(1,100)
        if (direction<2):     #pour un changement de direction plus nette et normale
            # Mouvement al√©atoire pour le navire pirate
            directions = [
                (VIT_MAX_NAVIRE_PIRATE, 0), (-VIT_MAX_NAVIRE_PIRATE, 0), 
                (0, VIT_MAX_NAVIRE_PIRATE), (0, -VIT_MAX_NAVIRE_PIRATE)
            ]
            vitX[pNoEntiteMobile], vitY[pNoEntiteMobile] = random.choice(directions)
    
    elif typesEntiteMobile[pNoEntiteMobile] == TYPE_ORGA_PETROL:
        # Comportement d√©j√† existant pour l'OP
        if etats_chargement[pNoEntiteMobile] == ETAT_CHARGEMENT_MAX:
            coordCible = getCelluleZoneUnique(BP)
        else:
            coordCible = getCelluleZoneUnique(PP)

        vitX[pNoEntiteMobile], vitY[pNoEntiteMobile] = 0, 0

        if round(coord_iEntitesMobiles[pNoEntiteMobile]) > coordCible[0]:
            vitX[pNoEntiteMobile] = -VIT_MAX_OrgaPetrole
        elif round(coord_iEntitesMobiles[pNoEntiteMobile]) < coordCible[0]:
            vitX[pNoEntiteMobile] = VIT_MAX_OrgaPetrole
        elif round(coord_jEntitesMobiles[pNoEntiteMobile]) > coordCible[1]:
            vitY[pNoEntiteMobile] = -VIT_MAX_OrgaPetrole
        elif round(coord_jEntitesMobiles[pNoEntiteMobile]) < coordCible[1]:
            vitY[pNoEntiteMobile] = VIT_MAX_OrgaPetrole
    else:
         
        direction = random.randint(1,100)
     
        #if (vitX[pNoEntiteMobile]==0 and vitY[pNoEntiteMobile]==0): #Changement de direction si nous sommes √† l'arr√™t
        if direction <= 2 :#25% de chance qu'il parte √† droite
            vitX[pNoEntiteMobile] = VIT_MAX_OrgaPetrole
            vitY[pNoEntiteMobile] = 0

        elif direction <= 4 :#25% de chance qu'il parte √† gauche
            vitX[pNoEntiteMobile] = -VIT_MAX_OrgaPetrole
            vitY[pNoEntiteMobile] = 0

        elif direction <= 6 :#25% de chance qu'il parte en bas
            vitX[pNoEntiteMobile] = 0
            vitY[pNoEntiteMobile] = VIT_MAX_OrgaPetrole

        elif direction <= 8:# de 75% et 100% inclus
            vitX[pNoEntiteMobile] = 0#25% de chance qu'il parte en haut
            vitY[pNoEntiteMobile] = -VIT_MAX_OrgaPetrole


"""
Obj: Gestion des d√©placements de chaque navire
Param :
    pNoEntiteMobile : Identifiant du navire concern√©

"""
def deplacement(pNoEntiteMobile):
    global entitesMobiles, vitX, vitY,coord_iEntitesMobiles,typesEntiteMobile,etats_chargement,budgetOM,budgetOP
    
    if typesEntiteMobile[pNoEntiteMobile] == NAVIRE_PIRATE:
        if vitX[pNoEntiteMobile] == 0 and vitY[pNoEntiteMobile] == 0:  # S'il est immobile, forcer un changement
            chgtDirectionOP(pNoEntiteMobile)
        elif random.random() < 0.1:  # Sinon, il a 10% de chance de changer de direction
            chgtDirectionOP(pNoEntiteMobile)


    #Relancer les navires ennemis
    if (typesEntiteMobile[pNoEntiteMobile]!=TYPE_ORGA_MARITIME):
        chgtDirectionOP(pNoEntiteMobile)
    #2.2 Correction Naviguation OP--
    
    
    #Cas de changement d'axe de direction > R√©aligner l'ancien
    if (vitX[pNoEntiteMobile]!=0):
        coord_jEntitesMobiles[pNoEntiteMobile]=round(coord_jEntitesMobiles[pNoEntiteMobile])
    else:#vitY!=0
        coord_iEntitesMobiles[pNoEntiteMobile]=round(coord_iEntitesMobiles[pNoEntiteMobile])
    
    #Incr√©mentation des coordonn√©es en fonction de la vitesse du navire
    coord_iEntitesMobiles[pNoEntiteMobile]+=vitX[pNoEntiteMobile]
    coord_jEntitesMobiles[pNoEntiteMobile]+=vitY[pNoEntiteMobile]    
    
    #identification des coordonn√©es de la cellule sur laquelle le navire s'engage 
    if (vitX[pNoEntiteMobile]>0 or vitY[pNoEntiteMobile]>0):
        coord_iEntiteMobile_matCarte=math.ceil(coord_iEntitesMobiles[pNoEntiteMobile])
        coord_jEntiteMobile_matCarte=math.ceil(coord_jEntitesMobiles[pNoEntiteMobile])
    else:
        coord_iEntiteMobile_matCarte=math.floor(coord_iEntitesMobiles[pNoEntiteMobile])
        coord_jEntiteMobile_matCarte=math.floor(coord_jEntitesMobiles[pNoEntiteMobile])
    
    #identification du type de d√©cor pr√©sent sur cette cellule
    typeCarte=(matValCarteN1[coord_jEntiteMobile_matCarte][coord_iEntiteMobile_matCarte])
    
    if (typeCarte>=ZT):#Cas de collision avec des zones non naviguables
        #Repositionnement du navire
        if (vitX[pNoEntiteMobile]>0):
            coord_iEntitesMobiles[pNoEntiteMobile]=coord_iEntiteMobile_matCarte-1
        elif (vitX[pNoEntiteMobile]<0):
            coord_iEntitesMobiles[pNoEntiteMobile]=coord_iEntiteMobile_matCarte+1
        elif (vitY[pNoEntiteMobile]>0):
            coord_jEntitesMobiles[pNoEntiteMobile]=coord_jEntiteMobile_matCarte-1
        elif (vitY[pNoEntiteMobile]<0):
            coord_jEntitesMobiles[pNoEntiteMobile]=coord_jEntiteMobile_matCarte+1
        
        #Arr√™t du navire
        vitX[pNoEntiteMobile]=0
        vitY[pNoEntiteMobile]=0
        
    #Cas de la nappe d'hydrocarbure arrivant dans une zone prot√©g√©e
    elif (typeCarte==ZP and typesEntiteMobile[pNoEntiteMobile]==TYPE_NAPPE_HYDRO and etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MAX):
            #Changer le statut de la cible
            matValCarteN1[coord_jEntiteMobile_matCarte][coord_iEntiteMobile_matCarte]=ZN
            #Modifier l'image
            gestionCanvas.itemconfig(matImgCarteN1[coord_jEntiteMobile_matCarte][coord_iEntiteMobile_matCarte], 
                                     image = imgZN)
            #mise √† jour du budget            
            budgetOM=int(budgetOM)-tarifDEGAT
            lblBudgetOM.config(text = "Budget OM : "+str(budgetOM))
            #sauvegarder_budget(budgetOM) # pour la sauvegarde du budget de OM
            afficher_budget_et_record()
    #Cas de l'arriv√©e d'un navire de l'OM charg√©e √† son port
    elif (typeCarte==BM and typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_MARITIME and etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MAX):
            #D√©chargement du navire de l'OM
            etats_chargement[pNoEntiteMobile]=ETAT_CHARGEMENT_MIN
            gestionCanvas.itemconfig(entitesMobiles[pNoEntiteMobile],image = imgBateauOMempty)
            #incr√©mentation du budget            
            budgetOM=int(budgetOM)+tarifTRAITEMENT
            lblBudgetOM.config(text = "Budget OM : "+str(budgetOM))
            #sauvegarder_budget(budgetOM)  # pour la sauvegarde du budget de OM
            afficher_budget_et_record()

    #Cas de l'arriv√©e d'un navire de l'OP vide √† la plateforme p√©troli√®re
    elif (typeCarte==PP and typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_PETROL and etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MIN):
            #Chargement du navire de l'OP
            etats_chargement[pNoEntiteMobile]=ETAT_CHARGEMENT_MAX
            gestionCanvas.itemconfig(entitesMobiles[pNoEntiteMobile],image = imgBateauOPfull)
            creationEntiteMobile(TYPE_NAPPE_HYDRO)
    #Cas de l'arriv√©e d'un navire de l'OP charg√©e √† son port
    elif (typeCarte==BP and typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_PETROL and etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MAX):
            #D√©chargement du navire de l'OP
            etats_chargement[pNoEntiteMobile]=ETAT_CHARGEMENT_MIN
            gestionCanvas.itemconfig(entitesMobiles[pNoEntiteMobile],image = imgBateauOPempty)
            #incr√©mentation du budget            
            budgetOP=int(budgetOP)+tarifVENTE
            lblBudgetOP.config(text = "Budget OP : "+str(budgetOP))
           # sauvegarder_budget(budgetOP)  # Sauvegarde OP
            afficher_budget_et_record()


    #Recherche de collision entre entites mobiles
    for a in range(0,len(entitesMobiles)):
        #Cas de l'interception de la nappe d'hydrocarbure a par le navire de l'OM pNoEntiteMobile
        if (typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_MARITIME and typesEntiteMobile[a]==TYPE_NAPPE_HYDRO):
            if (getCelluleEntiteMobile(a)==getCelluleEntiteMobile(pNoEntiteMobile)):
                if (etats_chargement[pNoEntiteMobile]==ETAT_CHARGEMENT_MIN and etats_chargement[a]==ETAT_CHARGEMENT_MAX):
                    #Changer le statut de la cible
                    matValCarteN1[coord_jEntiteMobile_matCarte][coord_iEntiteMobile_matCarte]=ZN
                    #Disparition de la nappe hydrocarbure
                    etats_chargement[a]=ETAT_CHARGEMENT_MIN
                    vitX[a]=0
                    vitY[a]=0
                    gestionCanvas.itemconfig(entitesMobiles[a],image = imgZN)
                    gestionCanvas.tag_lower(entitesMobiles[a])
                    budgetOP=int(budgetOP)-tarifSANCTION
                    lblBudgetOP.config(text = "Budget OP : "+str(budgetOP))
                    #Chargement du navire de l'OM
                    etats_chargement[pNoEntiteMobile]=ETAT_CHARGEMENT_MAX
                    gestionCanvas.itemconfig(entitesMobiles[pNoEntiteMobile],image = imgBateauOMfull)
                    
    
        #cas de l'interception du navire OP par mon navire pirate 
        elif (typesEntiteMobile[pNoEntiteMobile]==NAVIRE_PIRATE and typesEntiteMobile[a]==TYPE_ORGA_PETROL):
            # V√©rification si les deux navires sont dans la m√™me cellule
            if (getCelluleEntiteMobile(a) == getCelluleEntiteMobile(pNoEntiteMobile)):
                # V√©rification des √©tats de chargement
                if (etats_chargement[a] == ETAT_CHARGEMENT_MAX):  # Le navire OP √©tait charg√©
                    etats_chargement[a] = ETAT_CHARGEMENT_MIN  # Il perd son chargement
                    gestionCanvas.itemconfig(entitesMobiles[a], image=imgBateauOPempty)  # Mise √† jour de l'image
                    budgetOP -= tarifSANCTION  # R√©duction du budget OP
                    lblBudgetOP.config(text=f"Budget OP : {budgetOP}")  # Mettre √† jour l'affichage


    #Potentielle victoire et d√©faite
    if (typesEntiteMobile[pNoEntiteMobile]==TYPE_ORGA_MARITIME):
        (VictoireDefaite)()
        
        # pour mon bateau pirate 
    elif (typesEntiteMobile[pNoEntiteMobile]==NAVIRE_PIRATE):
        VictoireDefaite()
    
    #Repositonnement de l'image du navire en fonction de ses nouvelles coordonn√©es
    gestionCanvas.coords(entitesMobiles[pNoEntiteMobile],coord_iEntitesMobiles[pNoEntiteMobile]*LARG_CASE,coord_jEntitesMobiles[pNoEntiteMobile]*HAUT_CASE)

"""
Obj: R√©initiaisation toutes les positions et les vitesses et arr√™t des animations et d√©placements
"""
def depart():

    global vitX, vitY,typesEntiteMobile,dde_arret,etat_actif_depl_anim,budgetOM,budgetOP,etats_chargement
    global duree_partie, chrono_actif  # Ajout des variables globales
    
    #utilisateur()
    
    if (etat_actif_depl_anim==False):
        #Annulation de la vitesse en cours
        for i in range (len(vitX)):
            vitX[i]=0
        for i in range (len(vitY)):
            vitY[i]=0
    # R√©initialisation du temps uniquement si la partie n‚Äôa pas encore commenc√©
    if duree_partie == 0:
        duree_partie = 0
        lblDureePartie.config(text="Dur√©e : 0s")  # R√©initialise l'affichage
    
    chrono_actif = True  # Active le chronom√®tre
    miseAJourDuree()  # D√©marre le chrono
            
    for i in range(len(typesEntiteMobile)):
        if typesEntiteMobile[i] == NAVIRE_PIRATE:
            directions = [(VIT_MAX_NAVIRE_PIRATE, 0), (-VIT_MAX_NAVIRE_PIRATE, 0), (0, VIT_MAX_NAVIRE_PIRATE), (0, -VIT_MAX_NAVIRE_PIRATE)]
            vitX[i], vitY[i] = random.choice(directions)  # üè¥‚Äç‚ò†Ô∏è Donne une direction al√©atoire

        
        #R√©initialisation des √©tats de fonctionnement
        for i in range (len(etats_chargement)):
            if (typesEntiteMobile[i]==TYPE_NAPPE_HYDRO):
                etats_chargement[i]=ETAT_CHARGEMENT_MAX
            else:
                etats_chargement[i]=ETAT_CHARGEMENT_MIN
        #lblEtat.config(text = "Etat : "+str(etats_chargement[0])+"%")
    
        #Arr√™t des animations et d√©placement
        dde_arret = False
        etat_actif_depl_anim = True

        #2.1 Supression des Zones Nappes Hydro++
        nbNappesHydrocarbures=len(entitesMobiles)-(nbNavireOrgaMaritime+nbNavireOrgaPetroliere+nbNAVIREPIRATE)   #ajout de la variable nbNAVIREPIRATE pour la bon fonctionnement
        for i in range(nbNappesHydrocarbures):
            coord_iEntitesMobiles_Init.pop(-1)
            coord_jEntitesMobiles_Init.pop(-1)
            coord_iEntitesMobiles.pop(-1)
            coord_jEntitesMobiles.pop(-1)
            vitX.pop(-1)
            vitY.pop(-1)
            gestionCanvas.delete(entitesMobiles[-1])
            entitesMobiles.pop(-1)
         
        #2.1 Supression des Zones Nappes Hydro--
        #Repositionnement aux valeurs initiales        
        for noEntiteMobile in range(0,len(entitesMobiles)):  
            coord_iEntitesMobiles[noEntiteMobile]=coord_iEntitesMobiles_Init[noEntiteMobile]
            coord_jEntitesMobiles[noEntiteMobile]=coord_jEntitesMobiles_Init[noEntiteMobile]
            gestionCanvas.coords(entitesMobiles[noEntiteMobile],
                                 coord_iEntitesMobiles[noEntiteMobile]*LARG_CASE,
                                 coord_jEntitesMobiles[noEntiteMobile]*HAUT_CASE)
            if (typesEntiteMobile[noEntiteMobile]==TYPE_ORGA_MARITIME):
                gestionCanvas.itemconfig(entitesMobiles[noEntiteMobile],image = imgBateauOMempty)
            elif (typesEntiteMobile[noEntiteMobile]==TYPE_ORGA_PETROL):
                gestionCanvas.itemconfig(entitesMobiles[noEntiteMobile],image = imgBateauOPempty)
            # elif (typesEntiteMobile[noEntiteMobile]==NAVIRE_PIRATE):
            #     chgtDirectionOP(noEntiteMobile)
        
        #initialisation du budget            
        budgetOM=budgetOM_INIT
        budgetOP=budgetOP_INIT
        lblBudgetOM.config(text = "Budget OM : "+str(budgetOM))
        lblBudgetOP.config(text = "Budget OP : "+str(budgetOP))
        #initialisation de message de victoire & d√©faite
        lblMessage.config(text="")
        
        CreationImagesCarte()
        
        gestion_deplacements()
   


"""
Obj: Arr√™t des animations et d√©placements sans repositionner
"""
def arret():
    global dde_arret,etat_actif_depl_anim,chrono_actif
    if (etat_actif_depl_anim==True):
        #Mise √† jour de la variale globale utilis√©e dans les d√©placements
        dde_arret = True
        etat_actif_depl_anim=False
        chrono_actif = False  # Stopper le chronom√®tre
        sauvegarder_budget(budgetOM)    


"""
Obj: Verification des conditions de Victoire et de D√©faite
Dans le cas de victoire comme de d√©faite, le simulateur sera arr√™t√© et un message mis √† jour
"""
def VictoireDefaite():
    global matValCarteN1
    nbZonesDisponibles=0
    for i in range(len(matValCarteN1)):
        for j in range(len(matValCarteN1[i])):
            if (matValCarteN1[j][i]==ZN and (len(voisinsDisponibles(matValCarteN1,[ZN],j,i))==8)):
                nbZonesDisponibles+=1
    if (nbZonesDisponibles==0) or budgetOP < 0 :#Aucune zone disponible ajout ;
        arret()
        lblMessage.config(text="Victoire",fg='#0f0')
        # ajout pour mon chronometre
        chrono_actif = False  # Arr√™ter le chrono
        afficher_classement_final(budgetOM)  # Si budgetOM est le budget final
        afficher_graphe_final()
        
    elif budgetOM<0:    
        arret()
        lblMessage.config(text="D√©faite",fg='#f00')
        chrono_actif = False  # Arr√™ter le chrono
        afficher_classement_final(budgetOM)  # Si budgetOM est le budget final
        afficher_graphe_final()


"""
Obj: Cr√©er ou Recr√©er les images du d√©cor
"""
def CreationImagesCarte():
    global matValCarteN1,matImgCarteN1
    
    #Suppression de toutes les images de d√©cor d√©j√† pr√©sentes (cas de red√©marrage)
    for imgCarteLigne in matImgCarteN1:
        for j in imgCarteLigne:
            gestionCanvas.delete(j)
    matImgCarteN1.clear()
    
    #r√©initialisation des valeurs de la matrice
    matValCarteN1=np.copy(matValCarteN1_initial)
    
    #Cr√©ation
    for i in range(len(matValCarteN1)):
        imgCarteLigne=[]
        for j in range(len(matValCarteN1[i])):
            if (matValCarteN1[i][j]==ZN):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgZN,anchor=NW))
            elif (matValCarteN1[i][j]==ZP):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgZP,anchor=NW))
            elif (matValCarteN1[i][j]==ZT):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgZT,anchor=NW))
            elif (matValCarteN1[i][j]==BP):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgBP,anchor=NW))
            elif (matValCarteN1[i][j]==PP):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgPP,anchor=NW))
            elif (matValCarteN1[i][j]==BM):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgBM,anchor=NW))    
            elif (matValCarteN1[i][j]==CG):
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCG,anchor=NW))
            elif (matValCarteN1[i][j]==CD):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCD,anchor=NW))
            elif (matValCarteN1[i][j]==CDh):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCDh,anchor=NW))
            elif (matValCarteN1[i][j]==CGh):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCGh,anchor=NW))
            elif (matValCarteN1[i][j]==CH):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCH,anchor=NW))
            elif (matValCarteN1[i][j]==CB):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgCB,anchor=NW))
            elif (matValCarteN1[i][j]==cG):  
                imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgcG,anchor=NW))
            elif (matValCarteN1[i][j]==cD):  
                 imgCarteLigne.append(gestionCanvas.create_image(j*LARG_CASE, i*HAUT_CASE, image=imgcD,anchor=NW))
            gestionCanvas.tag_lower(imgCarteLigne[-1])#v0.5
        matImgCarteN1.append(imgCarteLigne)
        
def voisinsDisponibles(pLaby,pValsDisponibles,pX,pY):

    voisinsDisponibles=[]
    # voisins connexite 8
    voisins=[[0,1],[0,-1],[1,0],[-1,0],[1,1],[-1,1],[-1,-1],[1,-1]]
    for v in voisins:
        # coordonnees du voisin
        voisinX=pX+v[0]
        voisinY=pY+v[1]
        if pLaby[voisinX][voisinY] in pValsDisponibles:
            voisinsDisponibles.append([voisinX,voisinY])
            
    return voisinsDisponibles
    
# ----------------------------------------------------------------
# Corps du programme
# ----------------------------------------------------------------

#Param√©trage de la fen√™tre principale
fen_princ = Tk()
fen_princ.title("OCEAN WAR L1 SPI")
fen_princ.geometry("900x700")#Dimensions de la fen√™tre
fen_princ.bind("<Key>",evenements)#D√©finition de la fonction de gestion des √©v√®nements clavier
fen_princ.withdraw()   # masquer la fenetre et n'apparaitre qu'apres aoir lanc√© la simulation 

#Param√©trage du Canvas
gestionCanvas = Canvas(fen_princ, width=LARG_CANVAS, height=HAUT_CANVAS, bg='ivory', bd=0, highlightthickness=0)
gestionCanvas.grid(row=0,column=0, padx=10,pady=10)

#Affichage des diff√©rents types de zone
imgZN=PhotoImage(file = ("img/ocean40.gif"),master=fen_princ)
imgZP=PhotoImage(file = ("img/protection40.gif"),master=fen_princ)
imgZT=PhotoImage(file = ("img/terrainCC40.gif"),master=fen_princ)
imgBP=PhotoImage(file = ("img/port40red.gif"),master=fen_princ)
imgPP=PhotoImage(file = ("img/platform40.gif"),master=fen_princ)
imgBM=PhotoImage(file = ("img/port40green.gif"),master=fen_princ)
imgCG=PhotoImage(file = ("img/terrainHG40.gif"),master=fen_princ) #image pour la cote gauche 
imgCD=PhotoImage(file = ("img/terrainHD40.gif"),master=fen_princ) #image pour le cote droit
imgCGh=PhotoImage(file = ("img/terrainBG40.gif"),master=fen_princ) #image pour le coin gauche bas
imgCDh=PhotoImage(file = ("img/terrainBD40.gif"),master=fen_princ) #image pour le coin droite bas
imgCH=PhotoImage(file = ("img/terrainCH40.gif"),master=fen_princ) #image pour le cote haut
imgCB=PhotoImage(file = ("img/terrainCB40.gif"),master=fen_princ) #image pour le cote bas
imgcG=PhotoImage(file = ("img/terrainCG40.gif"),master=fen_princ) #image pour le coin gauche haut
imgcD=PhotoImage(file = ("img/terrainCD40.gif"),master=fen_princ) #image pour le coin droite haut
matImgCarteN1 = []

#Cr√©ation et positionnement des images du d√©cor en fonction des valeurs de matValCarteN1
CreationImagesCarte()

#Images utilis√©es pour l'affichage des navires
imgBateauOMfull=PhotoImage(file = ("img/bateauOMI40full.gif"),master=fen_princ)
imgBateauOMempty=PhotoImage(file = ("img/bateauOMI40empty.gif"),master=fen_princ)
imgZH=PhotoImage(file = ("img/hydrocarbure40a.gif"),master=fen_princ)
imgBateauOPfull=PhotoImage(file = ("img/bateauOPEP40full.gif"),master=fen_princ)
imgBateauOPempty=PhotoImage(file = ("img/bateauOPEP40empty.gif"),master=fen_princ)
imgNAVIREPIRATE=PhotoImage(file = ("img/ecoboat40.gif"),master=fen_princ)  #image pour mon navire pirate

#Cr√©ation des navires de l'OMI
nbNavireOrgaMaritime=1
for i in range(nbNavireOrgaMaritime):
    creationEntiteMobile(TYPE_ORGA_MARITIME)
    
#creation de mon navire pirate 
nbNAVIREPIRATE=5        
for i in range(nbNAVIREPIRATE):
    creationEntiteMobile(NAVIRE_PIRATE)

#Cr√©ation des navires de l'OP
nbNavireOrgaPetroliere=1
for i in range(nbNavireOrgaPetroliere):
    creationEntiteMobile(TYPE_ORGA_PETROL)

#Cr√©ation des nappes hydrocarbures 
nbNappesHydrocarbures=1
for i in range(nbNappesHydrocarbures):
    creationEntiteMobile(TYPE_NAPPE_HYDRO)



#Zone d√©di√©e aux boutons
zoneBtn = Frame(fen_princ)
zoneBtn.grid(row=0,column=1,ipadx=5)
  
#Boutons d'arr√™t et de r√©initialisation
lblMessage = Label(zoneBtn, text="")
Font_tuple = ("Comic Sans MS", 20, "bold")  
lblMessage.configure(font = Font_tuple) 
lblMessage.pack(fill=X)

lblBudgetOM = Label(zoneBtn, text="Budget OM")
lblBudgetOM.pack(fill=X)
lblBudgetOP = Label(zoneBtn, text="Budget OP")
lblBudgetOP.pack(fill=X)
btnArret = Button(zoneBtn, text="STOP", fg="yellow", bg="red", command=arret)
btnArret.pack(fill=X)
btnInit = Button(zoneBtn, text="START", fg="yellow", bg="green", command=depart)
btnInit.pack(fill=X)

#-----------------------------------------------------------------------------------------------------
# L'afficahge de mon record, du classement du record, du chronometre et le nom li√© au record
#-----------------------------------------------------------------------------------------------------

# affichage du record
lblBudgetRecord = Label(zoneBtn, text="Record : 0", fg="blue", bg="yellow", font=("calibri", 15))
lblBudgetRecord.pack(fill=X)
lblclassement = Label(zoneBtn, text="", fg="blue",bg="yellow", font=("century gothic", 15))
lblclassement.pack(fill=X)

# mise a jour du buget et du record
afficher_budget_et_record()   # Met √† jour l'affichage

# creation du widget pour mon chronometre
lblDureePartie = Label(zoneBtn, text="Dur√©e : 0s",fg="blue", bg="yellow",font=("calibri", 15))  # Affichage du temps
lblDureePartie.pack(fill=X)

# affichage du nom li√© au record √† l'interface 
lblNom = Label(zoneBtn, text=f"nom_utilisateur", fg="red",font=("Comic Sans MS", 15))



#----------------------------------------------------------------------------------
# Cr√©ation la fen√™tre du Menu principal
#----------------------------------------------------------------------------------
root = tk.Tk()
root.title("Eco-Guerrier - Menu Principal")
root.geometry("700x600")
root.withdraw()

# Titre du menu
titre = tk.Label(root, text="Eco-Guerrier", font=("calibri", 24, "bold"))
titre.pack(pady=40)

# Bouton pour afficher le tutoriel
btn_tutoriel = tk.Button(root, text="Consulter le tutoriel", command=afficher_tutoriel,font=("calibri", 14), bg="red", fg="yellow")
btn_tutoriel.pack(pady=20)


# Bouton pour lancer la simulation 
btn_lancer = tk.Button(root, text="lancer la simulation", command=lancerSimulation, font=("calibri", 14), bg="blue", fg="yellow")
btn_lancer.pack(pady=40)

# Bouton pour quitter
btn_quitter = tk.Button(root, text="Quitter", command=root.destroy, font=("calibri", 14), bg="yellow", fg="red")
btn_quitter.pack(pady=40)

#---------------------------------------------------------------------------------
# Cr√©ation de la fen√™tre pour l'insertion du nom
#---------------------------------------------------------------------------------

nom_window = tk.Toplevel(root)
nom_window.title("Nom du Guerrier")
nom_window.geometry("400x200")

# Texte d'instruction
tk.Label(nom_window, text="Saisissez votre nom pour commencer le jeu :", font=("calibri", 12)).pack(pady=10)

# Champ de saisie
entree_nom = tk.Entry(nom_window, font=("Arial", 12))
entree_nom.pack(pady=5)

# Bouton de validation
btn_valider = tk.Button(nom_window, text="Valider", command=utilisateur, font=("calibri", 12),bg="yellow", fg="red")
btn_valider.pack(pady=10)
#---------------------------------------------------------------------------------------------------------------

# Lancer l'interface du menu principal
root.mainloop()

#Rafraichissement de la fen√™tre et de tout son contenu
fen_princ.mainloop()
          </code></pre>
        </details>

        <p>
          üîΩ <a href="ProjetL1Algo25_v02.py" download>T√©l√©charger le script Python</a><br>
          üîó <a href="https://github.com/tonpseudo/eco-guerrier" target="_blank">Voir le projet sur GitHub</a>
        </p>
      </li>

      <li>
        <strong>Projet 2 : Simulateur Banque</strong><br>
        <p>Une application en Python avec interface graphique Tkinter permettant :</p>
        <ul>
          <li>la cr√©ation de comptes bancaires</li>
          <li>la consultation de soldes</li>
          <li>le d√©p√¥t et le retrait d'argent</li>
          <li>le transfert d'argent entre comptes</li>
        </ul>

        <p><strong>Code source :</strong></p>
        <details>
          <summary>Afficher/masquer le script complet</summary>
          <pre><code class="language-python">
"""
Projet : Simulateur Banque
@author: NADAL NGAKI MUPATI
"""
import tkinter as tk
FICHIER = "compte.txt"
            
# --- Fonctions de lecture/√©criture du fichier ---

def lire_compte():
    comptes = []
    try:
        with open(FICHIER, 'r') as f:
            for ligne in f:
                ligne = ligne.strip()
                if ligne:
                    nom, solde = ligne.split(',')
                    comptes.append((nom, float(solde)))
    except FileNotFoundError:
        pass
    return comptes

def ecrire_compte(comptes):
    with open(FICHIER, 'w') as f:
        for nom, solde in comptes:
            f.write(f"{nom},{solde}\n")

# --- Cr√©ation d'un compte avec fen√™tre secondaire ---

def creer_compte():
    def valider_creation():
        nom = entre_nom.get().strip()
        if not nom:
            label_result.config(text="‚ùå Nom invalide.")
            return

        comptes = lire_compte()
        for n, _ in comptes:
            if n == nom:
                label_result.config(text="‚ùå Ce nom a d√©j√† un compte.")
                fenetre_creation.destroy()
                return

        comptes.append((nom, 0.0))
        ecrire_compte(comptes)
        label_result.config(text=f"‚úÖ Compte cr√©√© pour {nom} avec un solde de 0 ‚Ç¨.")
        fenetre_creation.destroy()

    # Fen√™tre secondaire
    fenetre_creation = tk.Toplevel(root)
    fenetre_creation.title("Cr√©ation d'un compte")
    fenetre_creation.geometry("400x200")

    label_info = tk.Label(fenetre_creation, text="Saisir votre nom d'utilisateur :", font=("Arial", 12))
    label_info.pack(pady=10)

    entre_nom = tk.Entry(fenetre_creation, width=30)
    entre_nom.pack(pady=5)

    bouton_valider = tk.Button(fenetre_creation, text="Valider", command=valider_creation)
    bouton_valider.pack(pady=10)

# --- Voir le solde ---

def voir_solde():
    def valider_solde():
        nom = entre_nom1.get().strip()
        comptes = lire_compte()
    
        for n, solde in comptes:
            if n == nom:
                label_result.config(text=f"üí∞ Solde de {nom} : {solde} ‚Ç¨")
                fenetre_creation1.destroy()
                return
        label_result.config(text="‚ùå Compte introuvable.")
        fenetre_creation1.destroy()
        
        
    fenetre_creation1 = tk.Toplevel(root)
    fenetre_creation1.title("verification de solde")
    fenetre_creation1.geometry("400x200")

    label_info1 = tk.Label(fenetre_creation1, text="Saisir votre nom d'utilisateur :", font=("Arial", 12))
    label_info1.pack(pady=10)

    entre_nom1 = tk.Entry(fenetre_creation1, width=30)
    entre_nom1.pack(pady=5)
    
    bouton_valider1 = tk.Button(fenetre_creation1, text="Valider", command=valider_solde)
    bouton_valider1.pack(pady=10)

# --- D√©p√¥t d'argent ---

def faire_un_depot():
    def valider_depot():
        
        nom = entre_nom2.get().strip()
        try:
            montant = float(entre_montant2.get())
        except ValueError:
            label_result.config(text="‚ùå Montant invalide.")
            fenetre_creation2.destroy()
            return
    
        comptes = lire_compte()
        for i, (n, solde) in enumerate(comptes):
            if n == nom:
                comptes[i] = (n, solde + montant)
                ecrire_compte(comptes)
                label_result.config(text=f"‚úÖ {montant} ‚Ç¨ d√©pos√©s. Nouveau solde : {solde + montant} ‚Ç¨")
                fenetre_creation2.destroy()
                return
                
        label_result.config(text="‚ùå Compte introuvable.")
        fenetre_creation2.destroy()
        
    fenetre_creation2 = tk.Toplevel(root)
    fenetre_creation2.title("faire un depot")
    fenetre_creation2.geometry("400x200")

    label_info2 = tk.Label(fenetre_creation2, text="Saisir votre nom d'utilisateur :", font=("Arial", 12))
    label_info2.pack(pady=10)
    entre_nom2 = tk.Entry(fenetre_creation2, width=30)
    entre_nom2.pack(pady=5)
    
    label_montant2 = tk.Label(fenetre_creation2, text="Saisir le montant :", font=("Arial", 12))
    label_montant2.pack(pady=10)
    entre_montant2 = tk.Entry(fenetre_creation2, width=30)
    entre_montant2.pack(pady=5)
    
    bouton_valider2 = tk.Button(fenetre_creation2, text="Valider", command=valider_depot)
    bouton_valider2.pack(pady=10)
    

# --- Retrait d'argent ---

def faire_un_retrait():
    def valider_retrait():
        nom = entre_nom3.get().strip()
        try:
            montant = float(entre_montant3.get())
        except ValueError:
            label_result.config(text="‚ùå Montant invalide.")
            return
    
        comptes = lire_compte()
        for i, (n, solde) in enumerate(comptes):
            if n == nom:
                if solde >= montant:
                    comptes[i] = (n, solde - montant)
                    ecrire_compte(comptes)
                    label_result.config(text=f"‚úÖ {montant} ‚Ç¨ retir√©s. Nouveau solde : {solde - montant} ‚Ç¨")
                else:
                    label_result.config(text="‚ùå Fonds insuffisants.")
                    fenetre_creation3.destroy()
                return
        label_result.config(text="‚ùå Compte introuvable.")
        fenetre_creation3.destroy()
        
    
    fenetre_creation3 = tk.Toplevel(root)
    fenetre_creation3.title("faire un retrait")
    fenetre_creation3.geometry("400x200")

    label_info3 = tk.Label(fenetre_creation3, text="Saisir votre nom d'utilisateur :", font=("Arial", 12))
    label_info3.pack(pady=10)
    entre_nom3 = tk.Entry(fenetre_creation3, width=30)
    entre_nom3.pack(pady=5)
    
    label_montant3 = tk.Label(fenetre_creation3, text="Saisir le montant :", font=("Arial", 12))
    label_montant3.pack(pady=10)
    entre_montant3 = tk.Entry(fenetre_creation3, width=30)
    entre_montant3.pack(pady=5)
    
    bouton_valider3 = tk.Button(fenetre_creation3, text="Valider", command=valider_retrait)
    bouton_valider3.pack(pady=10)

# --- transfert d'argent ---
    
def faire_un_transfert():
    def valider_transfert():
        expediteur = entre_nom5.get().strip()
        destinataire = entre_nom6.get().strip()
        try:
            montant = float(entre_montant6.get())
        except ValueError:
            label_result.config(text="‚ùå Montant invalide.")
            fenetre_transfert.destroy()
            return

        comptes = lire_compte()
        index_expediteur = index_destinataire = -1

        for i, (nom, solde) in enumerate(comptes):
            if nom == expediteur:
                index_expediteur = i
            if nom == destinataire:
                index_destinataire = i

        if index_expediteur == -1:
            label_result.config(text="‚ùå Compte exp√©diteur introuvable.")
        elif index_destinataire == -1:
            label_result.config(text="‚ùå Compte destinataire introuvable.")
        elif comptes[index_expediteur][1] < montant:
            label_result.config(text="‚ùå Fonds insuffisants.")
        else:
            comptes[index_expediteur] = (expediteur, comptes[index_expediteur][1] - montant)
            comptes[index_destinataire] = (destinataire, comptes[index_destinataire][1] + montant)
            ecrire_compte(comptes)
            label_result.config(text=f"‚úÖ Transfert de {montant} ‚Ç¨ de {expediteur} √† {destinataire} r√©ussi.")

        fenetre_transfert.destroy()

    # Fen√™tre de transfert
    fenetre_transfert = tk.Toplevel(root)
    fenetre_transfert.title("Faire un transfert")
    fenetre_transfert.geometry("400x300")

    label_info5 = tk.Label(fenetre_transfert, text="Nom de l'exp√©diteur :", font=("Arial", 12))
    label_info5.pack(pady=5)
    entre_nom5 = tk.Entry(fenetre_transfert, width=30)
    entre_nom5.pack(pady=5)

    label_info6 = tk.Label(fenetre_transfert, text="Nom du b√©n√©ficiaire :", font=("Arial", 12))
    label_info6.pack(pady=5)
    entre_nom6 = tk.Entry(fenetre_transfert, width=30)
    entre_nom6.pack(pady=5)

    label_montant6 = tk.Label(fenetre_transfert, text="Montant √† transf√©rer :", font=("Arial", 12))
    label_montant6.pack(pady=5)
    entre_montant6 = tk.Entry(fenetre_transfert, width=30)
    entre_montant6.pack(pady=5)

    bouton_valider6 = tk.Button(fenetre_transfert, text="Valider", command=valider_transfert)
    bouton_valider6.pack(pady=10)

        

# --- Interface graphique principale ---

root = tk.Tk()
root.title("BANQUE FRANCE-AFRIQUE")
root.geometry("700x650")
root.configure(bg="#DDEEFF")

texte_accueil = (
    "Bienvenue dans votre espace client !\n\n"
    "Voici les op√©rations disponibles :\n"
    "1 - Cr√©er un compte : enregistrez un nouveau nom (solde initial = 0 ‚Ç¨)\n"
    "2 - Voir le solde : consultez votre solde actuel\n"
    "3 - Faire un d√©p√¥t : ajoutez de l‚Äôargent sur votre compte\n"
    "4 - Faire un retrait : retirez de l‚Äôargent (si solde suffisant)\n"
    "5 - faire un transfert : envoyez de l'argent √† un autre compte\n"
    "6 - Quitter\n"
)
label_intro = tk.Label(root, text=texte_accueil, justify="left", font=("calibri", 14), fg="red", wraplength=600)
label_intro.pack(pady=10)


label_result = tk.Label(root, text="", font=("arial", 14), fg="blue")
label_result.pack(pady=10)

frame_boutons = tk.Frame(root)
frame_boutons.pack(pady=10)

btn_creer = tk.Button(frame_boutons, text="1. Cr√©er un compte", width=30, command=creer_compte)
btn_creer.grid(row=0, column=0, pady=5)

btn_solde = tk.Button(frame_boutons, text="2. Voir le solde", width=30, command=voir_solde)
btn_solde.grid(row=1, column=0, pady=5)

btn_depot = tk.Button(frame_boutons, text="3. Faire un d√©p√¥t", width=30, command=faire_un_depot)
btn_depot.grid(row=2, column=0, pady=5)

btn_retrait = tk.Button(frame_boutons, text="4. Faire un retrait", width=30, command=faire_un_retrait)
btn_retrait.grid(row=3, column=0, pady=5)

btn_transfert = tk.Button(frame_boutons, text="5. Faire un transfert", width=30, command=faire_un_transfert)
btn_transfert.grid(row=3, column=0, pady=5)

btn_quitter = tk.Button(frame_boutons, text="6. Quitter", width=30, command=root.destroy)
btn_quitter.grid(row=4, column=0, pady=10)

root.mainloop()
          </code></pre>
        </details>

        <p>
          üîΩ <a href="PROJET1_BANQUE.py" download>T√©l√©charger le script Python</a><br>
          üîó <a href="https://github.com/nadal243/banque-simulateur" target="_blank">Voir le projet sur GitHub</a>
        </p>
      </li>
    
      <li>
        <strong>Projet 3 : Visualiseur de Donn√©es CSV/Excel</strong><br>
        <p>
          Une application Python avec interface Tkinter permettant de visualiser graphiquement des donn√©es provenant de fichiers CSV ou Excel.
        </p>
        <ul>
          <li>Chargement dynamique de fichiers .csv ou .xlsx</li>
          <li>S√©lection des colonnes X et Y</li>
          <li>Types de graphiques : courbes, barres, nuages de points, histogrammes</li>
          <li>Fonction zoom/d√©zoom et r√©initialisation</li>
          <li>Export du graphique en PNG</li>
        </ul>

        <p><strong>Code source :</strong></p>
        <details>
          <summary>Afficher/masquer le script complet</summary>
          <pre><code class="language-python">
"""
Created on Fri May 30 15:24:08 2025

@author: NADAL NGAKI MUPATI
"""

# Importation des biblioth√®ques n√©cessaires pour l'interface graphique, le traitement de donn√©es et la visualisation
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import os 

class VisualiseurCSV:
    def __init__(self, root):
        self.root = root
        self.root.title("Visualiseur des donn√©es CSV")
        self.root.geometry("1000x750")

        self.df = None
        self.canvas = None
        
        # Cr√©er deux frames pour s√©parer les contr√¥les (gauche) et le graphique (droite)
        # Zone de gauche : contient les boutons et menus
        self.frame_gauche = tk.Frame(self.root)
        # Zone de droite : affichera le graphique
        self.frame_droite = tk.Frame(self.root)
        # Zone de gauche : contient les boutons et menus
        self.frame_gauche.pack(side=tk.LEFT, padx=20, pady=20, anchor='n')
        # Zone de droite : affichera le graphique
        self.frame_droite.pack(side=tk.LEFT, padx=20, pady=20, anchor='n')

        # -------- Interface utilisateur : affichage d'instructions --------
        label_info = tk.Label(
            self.frame_gauche,
            text="Bienvenue dans le visualiseur de donn√©es\n\n"
                 "1. Importez un fichier CSV ou Excel\n"
                 "2. Choisissez les colonnes X et Y\n"
                 "3. Choisissez le type de graphique\n"
                 "4. Cliquez sur 'Tracer le graphique'",
            justify="left",
            font=("Calibri", 12)
        )
        label_info.pack(pady=10)
        
        

        # Bouton pour charger un fichier CSV
        self.btn_charger = tk.Button(self.frame_gauche, text="Charger un fichier", command=self.charger_csv)
        self.btn_charger.pack(pady=10)

        # Combobox pour s√©lectionner les colonnes X et Y √† partir des donn√©es
        self.colonne_x = ttk.Combobox(self.frame_gauche, state='readonly')
        self.colonne_y = ttk.Combobox(self.frame_gauche, state='readonly')
        self.colonne_x.pack(pady=5)
        self.colonne_y.pack(pady=5)
        
        # S√©lection du type de graphique
        label_info = tk.Label(self.frame_gauche, text="selectionnez le type de graphique:", font=("calibri", 12))
        label_info.pack(pady=5)
        
        self.type_graphique = ttk.Combobox(self.frame_gauche, state='readonly')
        self.type_graphique['values'] = ['Ligne', 'Nuage de points', 'Barres', 'Histogramme']
        self.type_graphique.current(0)
        self.type_graphique.pack(pady=5)

        # Bouton pour tracer le graphique
        self.btn_tracer = tk.Button(self.frame_gauche, text="Tracer le graphique", command=self.tracer_graphique)
        self.btn_tracer.pack(pady=10)
        
        # Boutons de zoom
        self.btn_zoom_in = tk.Button(self.frame_gauche, text="Zoomer", command=self.zoom_in)
        self.btn_zoom_out = tk.Button(self.frame_gauche, text="D√©zoomer", command=self.zoom_out)
        self.btn_reset_zoom = tk.Button(self.frame_gauche, text="R√©initialiser le zoom", command=self.reset_zoom)
        
        self.btn_zoom_in.pack(pady=5)
        self.btn_zoom_out.pack(pady=5)
        self.btn_reset_zoom.pack(pady=5)
        
        # Bouton pour sauvegarder le graphique
        self.btn_sauvegarder = tk.Button(self.frame_gauche, text="sauvegarder le graphique", command=self.SauvegaderGraphique)
        self.btn_sauvegarder.pack(pady=5)
        
        # Bouton pour supprimer le graphique
        self.btn_supprimer = tk.Button(self.frame_gauche, text="supprimer le graphique", command=self.supprimer_graphique)
        self.btn_supprimer.pack(pady=5)

    def charger_csv(self):
        # -------- Chargement du fichier CSV et extraction des colonnes --------
        chemin = filedialog.askopenfilename(
            filetypes=[
                ("Fichiers CSV et Excel", "*.csv *.xls *.xlsx"),
                ("Fichiers CSV", "*.csv"),
                ("Fichiers Excel", "*.xls *.xlsx")])
        if chemin:
            try:
                ext = os.path.splitext(chemin)[1].lower()
                if ext == ".csv":
                    self.df = pd.read_csv(chemin)
                elif ext in [".xls", ".xlsx"]:
                    self.df = pd.read_excel(chemin)
                else:
                    messagebox.showerror("Erreur, Format de fichier non pris en charge.")
                colonnes = list(self.df.columns)
                self.colonne_x['values'] = colonnes
                self.colonne_y['values'] = colonnes
                messagebox.showinfo("Succ√®s", "Fichier charg√© avec succ√®s.")
            except Exception as e:
                messagebox.showerror("Erreur", f"Impossible de lire le fichier :\n{e}")

    def tracer_graphique(self):
        # -------- V√©rification des conditions minimales --------
        if self.df is None:
            messagebox.showwarning("Attention", "Aucun fichier charg√©.")
            return

        x_col = self.colonne_x.get()
        y_col = self.colonne_y.get()
        type_graph = self.type_graphique.get()

        if not x_col or not y_col:
            messagebox.showwarning("Attention", "Veuillez s√©lectionner les colonnes X et Y.")
            return

        try:
            # -------- Nettoyage des donn√©es : conversion en num√©rique et suppression des valeurs manquantes --------
            self.df[x_col] = pd.to_numeric(self.df[x_col], errors='coerce')
            self.df[y_col] = pd.to_numeric(self.df[y_col], errors='coerce')
            self.df.dropna(subset=[x_col, y_col], inplace=True)

            fig, ax = plt.subplots(figsize=(6, 4))
            self.ax = ax 

            # -------- Trac√© du graphique selon le type s√©lectionn√© --------
            if type_graph == 'Ligne':
                ax.plot(self.df[x_col], self.df[y_col], marker='o')  # Graphique en ligne
            elif type_graph == 'Nuage de points':
                ax.scatter(self.df[x_col], self.df[y_col])           # Nuage de points
            elif type_graph == 'Barres':
                ax.bar(self.df[x_col], self.df[y_col])              # Diagramme en barres
            elif type_graph == 'Histogramme':
                ax.hist(self.df[y_col], bins=20, edgecolor='black') # Histogramme simple
                ax.set_xlabel(y_col)
                ax.set_ylabel("Fr√©quence")
                ax.set_title(f"Histogramme de {y_col}")
                ax.grid(True)
            else:
                messagebox.showwarning("Erreur", "Type de graphique non reconnu.")
                return

            # -------- Param√©trage g√©n√©ral pour les autres types --------
            if type_graph != 'Histogramme':
                ax.set_xlabel(x_col)
                ax.set_ylabel(y_col)
                ax.set_title(f"{y_col} en fonction de {x_col}")
                ax.grid(True)

            # Suppression de l'ancien graphique si pr√©sent
            if self.canvas:
                self.canvas.get_tk_widget().destroy()

            # Affichage du graphique dans l‚Äôinterface Tkinter
            self.canvas = FigureCanvasTkAgg(fig, master=self.frame_droite)
            self.canvas.draw()
            self.canvas.get_tk_widget().pack(pady=10)
            
            # FORCER le rendu puis sauvegarder les limites d'origine
            fig.canvas.draw()  # Tr√®s important
            self.original_xlim = self.ax.get_xlim()
            self.original_ylim = self.ax.get_ylim()
            
            # -------- Sauvegarde temporaire de la figure pour la fonction de sauvegarde --------
            self.current_fig = fig

        except Exception as e:
            messagebox.showerror("Erreur", f"Erreur lors du trac√© :\n{e}")
                
    def SauvegaderGraphique(self):
        # -------- Sauvegarde du graphique affich√© en tant qu‚Äôimage PNG --------
        if hasattr(self, 'current_fig'):
            fichier = filedialog.asksaveasfilename(defaultextension='.png',
                                                   filetypes=[("Fichier PNG", "*.png")])
            if fichier:
                try:
                    self.current_fig.savefig(fichier)
                    messagebox.showinfo("Succ√®s", "Graphique sauvegard√© avec succ√®s.")
                except Exception as e:
                    messagebox.showerror("Erreur", f"Impossible de sauvegarder le graphique :\n{e}")
        else:
            messagebox.showwarning("Avertissement", "Aucun graphique √† sauvegarder.")
            
    def zoom_in(self):
        if self.ax:
            xlim = self.ax.get_xlim()
            ylim = self.ax.get_ylim()
            self.ax.set_xlim([xlim[0] + (xlim[1] - xlim[0]) * 0.1, xlim[1] - (xlim[1] - xlim[0]) * 0.1])
            self.ax.set_ylim([ylim[0] + (ylim[1] - ylim[0]) * 0.1, ylim[1] - (ylim[1] - ylim[0]) * 0.1])
            self.canvas.draw()

    def zoom_out(self):
        if self.ax:
            xlim = self.ax.get_xlim()
            ylim = self.ax.get_ylim()
            self.ax.set_xlim([xlim[0] - (xlim[1] - xlim[0]) * 0.1, xlim[1] + (xlim[1] - xlim[0]) * 0.1])
            self.ax.set_ylim([ylim[0] - (ylim[1] - ylim[0]) * 0.1, ylim[1] + (ylim[1] - ylim[0]) * 0.1])
            self.canvas.draw()
    
    def reset_zoom(self):
        if self.ax:
            if hasattr(self, 'original_xlim') and hasattr(self, 'original_ylim'):
                self.ax.set_xlim(self.original_xlim)
                self.ax.set_ylim(self.original_ylim)
            else:
                self.ax.relim()
                self.ax.autoscale_view()
            self.canvas.draw()
    
    def supprimer_graphique(self):
    #-----------permet d'effacer le graphique--------
        if self.canvas:
            self.canvas.get_tk_widget().destroy()
            self.canvas = None
            self.ax = None
            if hasattr(self, 'original_xlim'):
                del self.original_xlim
            if hasattr(self, 'original_ylim'):
                del self.original_ylim

# -------- Lancement de l'application --------
if __name__ == "__main__":
    root = tk.Tk()
    app = VisualiseurCSV(root)
    root.mainloop()

          </code></pre>
        </details>

        <p>
          üîΩ <a href="PROJET_visualiseur des donn√©es.py" download>T√©l√©charger le script Python</a><br>
          üîó <a href="https://github.com/nadal243/visualiseur-csv-excel" target="_blank">Voir le projet sur GitHub</a>
        </p>
      </li>
</ul>
  </section

      
      <li>
        <strong>Projet 4 : Vid√©o surveillance</strong><br>
        <p>Une application en Python avec interface graphique Tkinter permettant :</p>
        <ul>
          <li> Capture vid√©o en direct via la webcam : Utilise OpenCV pour afficher le flux vid√©o dans une interface Tkinter</li>
          <li>D√©tection de mouvement : Compare les images successives en niveaux de gris pour d√©tecter un changement significatif (mouvement)</li>
          <li>Enregistrement automatique : Lance un enregistrement vid√©o (format .avi) lorsqu‚Äôun mouvement est d√©tect√©, et l‚Äôarr√™te apr√®s 5 secondes d‚Äôinactivit√©</li>
          <li>Alerte sonore et message pop-up : Lorsqu‚Äôun mouvement est d√©tect√©, le programme joue un son d‚Äôalerte (alerte.mp3) et affiche une notification √† l‚Äô√©cran</li>
        </ul>

          <p><strong>Code source :</strong></p>
          <details>
            <summary>Afficher/masquer le script complet</summary>
            <pre><code class="language-python">
"""
Created on Mon Jun  9 12:30:45 2025
@author: NGAKI MUPATI NADAL
"""

import tkinter as tk  # Pour cr√©er l'interface graphique
import cv2  # OpenCV pour la capture vid√©o et le traitement d'image
# import face_recognition  # (D√©sactiv√© ici, pas utilis√© dans cette version)
from PIL import Image, ImageTk  # Pour afficher les images OpenCV dans Tkinter
from tkinter import messagebox  # Pour afficher des messages pop-up
import time  # Pour mesurer le temps √©coul√© (utile pour l'enregistrement)
from playsound import playsound  # Pour jouer un fichier audio (alerte sonore)


class SurveillanceApp:
    def __init__(self, root):
        self.root = root  
        self.root.title("Syst√®me de vid√©osurveillance intelligent") 
        self.root.geometry("800x600") 

        # Initialisation des variables de contr√¥le
        self.video_capture = None         # Objet pour capturer la vid√©o (webcam)
        self.running = False              # Indique si la cam√©ra tourne
        self.previous_frame = None        # Image pr√©c√©dente en niveaux de gris (pour comparaison)
        self.video_writer = None          # Objet pour √©crire les vid√©os sur le disque
        self.recording = False            # Indique si un enregistrement est en cours
        self.last_motion_time = None      # M√©morise le moment du dernier mouvement

        # Interface graphique avec Tkinter
        self.label_video = tk.Label(self.root)  # √âtiquette pour afficher la vid√©o
        self.label_video.pack(pady=10)

        # Bouton pour d√©marrer la cam√©ra
        self.btn_start = tk.Button(self.root, text="D√©marrer", command=self.start_camera)
        self.btn_start.pack(side=tk.LEFT, padx=20)

        # Bouton pour arr√™ter la cam√©ra
        self.btn_stop = tk.Button(self.root, text="Arr√™ter", command=self.stop_camera, state=tk.DISABLED)
        self.btn_stop.pack(side=tk.LEFT, padx=20)

        # Bouton pour quitter l'application
        self.btn_quit = tk.Button(self.root, text="Quitter", command=self.quit_app)
        self.btn_quit.pack(side=tk.RIGHT, padx=20)

    def start_camera(self):
        # Ouvre la webcam (0 = webcam par d√©faut du PC)
        self.video_capture = cv2.VideoCapture(0)
        self.running = True  # Active la boucle de mise √† jour
        self.btn_start.config(state=tk.DISABLED)
        self.btn_stop.config(state=tk.NORMAL)
        self.MiseAJour_cadre()  # Commence √† lire les images

    def MiseAJour_cadre(self):
        # Fonction appel√©e en boucle pour afficher la vid√©o et d√©tecter les mouvements
        if self.running:
            ret, frame = self.video_capture.read()  # Capture une image
            if ret:
                # Convertit l'image couleur en niveaux de gris
                frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                # Applique un flou pour r√©duire les petits mouvements (bruit)
                frame_gray = cv2.GaussianBlur(frame_gray, (21, 21), 0)

                if self.previous_frame is None:
                    # Premi√®re image, on la garde pour comparer plus tard
                    self.previous_frame = frame_gray
                else:
                    # Compare l'image actuelle avec la pr√©c√©dente
                    diff = cv2.absdiff(self.previous_frame, frame_gray)
                    _, thresh = cv2.threshold(diff, 25, 255, cv2.THRESH_BINARY)  # Binarise la diff√©rence
                    motion_level = cv2.countNonZero(thresh)  # Compte les pixels blancs (changements)

                    if motion_level > 5000:  # Si beaucoup de pixels ont chang√© ‚Üí mouvement d√©tect√©
                        self.last_motion_time = time.time()  # On enregistre le moment du mouvement

                        if not self.recording:
                            # Si on ne filmait pas encore ‚Üí d√©marrer un nouvel enregistrement
                            fourcc = cv2.VideoWriter_fourcc(*'XVID')  # Format de vid√©o .avi
                            self.video_writer = cv2.VideoWriter("mouvement.avi", fourcc, 20.0, (frame.shape[1], frame.shape[0]))
                            self.recording = True  # Indique qu'on est en train d'enregistrer
                            messagebox.showinfo("D√©tection", "Mouvement d√©tect√© - enregistrement lanc√©")

                            # Alerte sonore
                            playsound("alerte.mp3", block=False)

                        # Enregistrement actif : on ajoute chaque image captur√©e √† la vid√©o
                        if self.video_writer is not None:
                            self.video_writer.write(frame)

                    # Si 5 secondes sont pass√©es sans mouvement ‚Üí arr√™ter l'enregistrement
                    if self.recording and self.last_motion_time and (time.time() - self.last_motion_time > 5):
                        self.video_writer.release()  # Ferme le fichier vid√©o
                        self.video_writer = None
                        self.recording = False
                        messagebox.showinfo("Info", "Enregistrement termin√©")

                    # Sauvegarder la derni√®re image pour la prochaine comparaison
                    self.previous_frame = frame_gray

                # Affiche l'image actuelle dans l'interface graphique
                img = Image.fromarray(frame)  # Convertit OpenCV ‚Üí Image PIL
                imgtk = ImageTk.PhotoImage(image=img)  # Convertit Image PIL ‚Üí Tkinter
                self.label_video.imgtk = imgtk
                self.label_video.configure(image=imgtk)

            # Rappelle cette fonction apr√®s 10 ms (boucle d'actualisation)
            self.root.after(10, self.MiseAJour_cadre)

    def stop_camera(self):
        # Arr√™te la cam√©ra et lib√®re les ressources
        self.running = False
        self.btn_start.config(state=tk.NORMAL)
        self.btn_stop.config(state=tk.DISABLED)
        if self.video_capture:
            self.video_capture.release()
            self.label_video.config(image="")

        self.previous_frame = None  # R√©initialise l'image pr√©c√©dente

        # Si une vid√©o √©tait en cours ‚Üí on la termine proprement
        if self.recording and self.video_writer:
            self.video_writer.release()
            self.video_writer = None
            self.recording = False

    def quit_app(self):
        # Ferme proprement l'application
        self.stop_camera()
        self.root.destroy()


# Lancement de l'application principale
if __name__ == "__main__":
    root = tk.Tk()
    app = SurveillanceApp(root)
    root.mainloop()

      </code></pre>
            </details>
        <p>
          üîΩ <a href="SurveillanceVideo.py" download>T√©l√©charger le script Python</a><br>
          üîó <a href="https://github.com/tonpseudo/eco-guerrier" target="_blank">Voir le projet sur GitHub</a>
        </p>
  </li>

  <footer>
    <p>Contact : nadalngaki@gmail.com</p>
  </footer>
</body>
</html>
